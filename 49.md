
NIP-49
======

Private Key Transfer
--------------------

`draft` `optional` `author:mikedilger`

This NIP defines a method by which clients can export and/or import a password-encrypted private key for the purposes of moving it between clients.

Key derivation
--------------

The key used to encrypt/decrypt the private key is generated from a password.
This same process is used for both encryption and decryption, and is not reversable.

Create a 15-byte random salt. Prepend it with the byte 0x01 which represents the version number of this NIP algorithm.

Perform PBKDF2 using HMAC-SHA-256 on the password as bytes, salted with the salt, and run for 100,000 cycles.

Notes about the number of cycles: Encrypting and decrypting a key is not a common operation and can take a number of seconds. Those wishing to brute force guess passwords will be slowed down considerably by these required rounds.


Encrypting/Decrypting a private key
-----------------------------------

In short, the encryption/export process goes:

 - Concatenate the input:
     - Start with the 32 raw bytes (not the hex encoded string) of the private key
     - Append these bytes: [15, 91, 241, 148, 90, 143, 101, 12, 172, 255, 103]
     - Append a `0` if the key has been carelessly handled (printed, cut-n-paste, saved to disk, etc, while not encrypted) or a `1` if it is not known to have been carelessly handled.
 - Generate a random 16-byte initialization vector for AES-256, called IV
 - Pad the input as required by AES to 48 bytes.
 - Encrypt the padded input with AES-256-CBC using the randomly generated IV and the key generated from the previous section. The result should be 48 bytes long.
 - Concatenate the output:
     - Start with the 16-byte salt used in the key derivation step above
     - Append the 16-byte IV
     - Append the ciphertext output of AES (the total should now be 80 bytes)
 - Encode using base64 using the standard alphabet from RFC 3548

The decryption process is the reverse of the encryption process

 - Decode the input using base64 using the standard alphabet from RFC 3548. The result should be 80 bytes long.
 - Split the input considering the first 16 bytes as the salt, the next 16 bytes as the AES IV, and the rest as ciphertext
 - The salt should start with 0x01.
 - Decrypt the ciphertext with AES-256-CBC using the IV and the key generated from the previous section using the salt. The output should be 44 bytes long.
 - Split the output into three pieces
     - The first 32 bytes, which are the private key
     - The next 11 bytes, which must equal [15, 91, 241, 148, 90, 143, 101, 12, 172, 255, 103] or else there was an error.
     - The final byte which must be either `0` or `1` indicating key security

Keeping key material secure
---------------------------

It is strongly recommended that software that engages in this process zeroes the memory used by private keys and passwords before freeing it to the operating system.

Posting the encrypted private key to a relay
--------------------------------------------

To share the key with yourself at another client, the encrypted private key can be posted as the content of a nostr event using the event kind of 10002.

Test Data
---------

The following encrypted private key:

`AZQYNwAGULWyKweTtw6WCljV+1cil8IMRxfZ7Rs3nCfwbVQBV56U6eV9ps3S1wU7ieCx6EraY9Uqdsw71TY5Yv/Ep6yGcy9m1h4YozuxWQE=`

When decrypted with the password 'nostr' yields the following hex-encoded private key:

`a28129ab0b70c8d5e75aaf510ec00bff47fde7ca4ab9e3d9315c77edc86f037f`

The reverse process is non-deterministic due to the random IV.

Motivation
----------

There will always be a wide selection of clients. Users should be able to move/share their identity between them without risking exposing their private key. Short of the use of hardware security token support, this NIP provides the next best solution.
